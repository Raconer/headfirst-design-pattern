# HeadFirst - Design Pattern

## 오리 시뮬레이션 게임(SimUduck) - 기본 프로젝트 시나리오

> 오리 시뮬레이션 게임을 초기 클래스 구조를 바탕으로 하나씩 개선해 나가는 방식으로 공부가 진행되니 차례데로 순서를 따라와야한다.

## 공부 순서

1. wrongCode

> 아래와 같은 상황이면 괜찮지만 fly(), feathers()와 같은 여러 메소드가 생성되면 많은 문제가 발생한다.
> 그래서 이러한 구조는 잘못된 구조이다.

발생할 수 있는 문제

1. 모든 오리가 fly()를 가지게 됨 
   * 오리는 날지 못하는 경우도 있음 (RubberDuck, WoodenDuck 등).
     fly()가 필요 없는 오리도 해당 메서드를 가지게 되어 불필요한 코드 증가. 
2. 중복 코드 증가
   * 모든 오리 클래스에서 fly()를 오버라이딩하여 수정해야 할 가능성이 있음.
      동일한 동작을 여러 곳에서 구현하면 유지보수가 어려워짐.
3. 확장성 문제
   * fly(), quack() 등 새로운 행동을 추가할 때, 기존 모든 오리 클래스에 영향을 미침.
   새로운 오리 종류가 추가될 때마다 메서드 재정의가 필요.
4. SRP(단일 책임 원칙) 위반
   * Duck 클래스가 오리의 행동까지 관리하게 되어 하나의 클래스가 여러 책임을 가짐.
   fly(), quack() 같은 행동은 별도의 책임을 가진 클래스로 분리하는 것이 바람직.
5. 인터페이스 격리 원칙 위반
   * 날지 않는 오리도 fly()를 구현해야 하므로 불필요한 인터페이스를 강제하게 됨.
   fly()가 필요 없는 오리는 해당 메서드를 빈 메서드로 구현해야 할 수도 있음.
6. 유지보수 어려움
   * 특정 행동을 수정하려면 모든 관련 클래스를 찾아서 변경해야 함.
   코드가 점점 커지면서 유지보수가 복잡해짐.