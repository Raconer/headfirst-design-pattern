# 1. 전략 패턴(Strategy Pattern)
## 정의
> 알고리즘군을 정의하고 캡슐화해서 각각의 알고리즘군을 수정해서 쓸 수 있게 해 줍니다. 
> 전략 패턴을 사용하면 클라이언트로부터 알고리즘을 분리해서 독립적으로 변경할 수 있습니다.

## 시나리오 (오리 시뮬레이터)
1. 게임에서 여러 종류의 오리(청둥오리, 고무오리, 모형 오리 등)를 시뮬레이션해야 한다.
2. 오리마다 날 수 있는 오리와 날지 못하는 오리, 다른 울음소리를 내는 오리가 존재한다.
   * 모든 오리 클래스(Duck)가 fly()와 quack() 메서드를 포함하도록 상속을 사용했다.
   * 문제는 날지 못하는 오리(고무오리, 모형오리)도 fly() 메서드를 가지게 되는 것.
   * fly()를 오버라이드해서 빈 메서드로 만들 수도 있지만, 이렇게 하면 코드 중복과 유지보수 문제가 발생한다.
3. 전략 패턴 적용 후
   * fly()와 quack()을 별도의 인터페이스(전략)로 분리한다.
   * FlyBehavior와 QuackBehavior를 정의하고, 오리가 필요한 전략을 동적으로 할당할 수 있도록 변경한다.
   
## 문제를 명확하게 파악하기
* **상속의 한계** : 서브클래스마다 행동이 다를 수 있지만, 상속을 사용하면 하나의 행동만 강제됨.
* **인터페이스의 한계** : Flyable, Quackable 같은 인터페이스를 사용하면 특정 행동을 구현할 수는 있지만, **코드 재사용**이 **불가능**함.
* **문제점** : 새로운 행동을 추가하거나 변경할 때, 관련된 모든 서브클래스를 수정해야 하고, 이 과정에서 버그가 발생할 가능성이 높음.
* **해결책(디자인 원칙)** : 행동을 개별적인 클래스로 분리하고 필요할 때 객체에서 동적으로 변경할 수 있도록 함. (즉, 전략 패턴 사용)

## 디자인 원칙
> **바뀌는 부분**은 따로 뽑아서 **캡슐화** 한다. 
> 그러면 나중에 **바뀌지 않는 부분**에는 영향을 미치지 않고 **그 부분만 고치거나 확장**할 수 있다.

## 바뀌는 부분과 그렇지 않은 부분 분리하기

* 바뀌는 부분
  * fly()
  * quack()
* 바뀌지 않은 부분
  * 나머지 부분
